"Come together, right now, over me"
<sup>The Beatles - Come Together</sup>


The Software Development Life Cycle (SDLC for short) is the process used by developers in which they <u>design, develop and test</u> their software. It consists of a <u>detailed plan</u> for devs on how to develop and maintain their product. The main purpose of this is to **produce a high-quality and long-term maintained product** for consumers to use.

The phases of SDLC usually consist of these:
- Planning & Requirement Analysis
- Designing
- Coding
- Testing
- Deployment and Maintenance





## The **<u>Planning & Requirement Analysis</u>** Phase

This is the part of the Cycle<sup>TM</sup> where we try figure out what exactly the consumer wants and what goal our product should achieve. There are 3 types of **requirements** here.

### 1. Business Requirements

These requirements have to do with that the *consumers themselves actually want*. Think of this as the sort of starting point for everything else, where you would try figure out *what the people actually want or are having problems with.*

These requirements can usually be found with:
- Surveys
- Customer Reviews
- Meetings
- Brainstorming

From these, the team makes a <u>Requirements Document</u> where they document their findings.



### 2. Non-Functional Requirements

These have to do with <u>what</u> the product is <u>actually supposed to do</u>. Basically, these handle the **features** that the product will have. For example:

The Obsidian Note-taking app should be able to:
- Allow me to make notes
- Make folders
- Link multiple notes together and show them in a constellation-style graphic



### 3. Functional Requirements

Lastly, the Functional Requirements are regarding <u>how the system should do it</u>. You can think of it as the *performance requirements*.

The Obsidian Note-taking app should be able to:
- Open in less than 2 seconds
- Make a new .MD file in 1 second






## The **<u>Design</u>** Phase


By now, we would have <u>defined the solution system</u> based on the requirements we have gathered [[#1. Business Requirements|here]]. We would also be <u>building prototypes</u> to show the end-user <u>what the system would look like</u>.

Pretty short phase, but yeah. That's more or less all of what's in the slides.






## The **<u>Coding</u>** Phase - Implementation

"Where actual development starts!"

This is where according to the [[#1. Business Requirements|Requirements Document]], devs start making the software.

Programming software is different with the type of software being developed. 
E.g. 
Data Science Model-Python
Android Apps- Java






## The **<u>Testing</u>** Phase

This is probably the largest phase in terms of content we have to learn, so let's get into it.

So we're starting off with the different types of testing there are.

- Types of tests
  
	- Unit Testing
		- Testing each component of the software in isolation
		  
	- Integration Testing
		- Testing components as groups where they are combined.
		  
	- System Testing
		- All components are combined into one software and tested.
		  
	- Acceptance Testing
		- Formal testing abiding to the user requirements
		
	
	
	- Black Box Testing
		- The inner-workings of the program (design, code and implementation, etc.) are **unknown to the tester**
		- Done by <u>software testers</u>
		- <u>No knowledge of the code</u> is required
		- Outer or external software testing
	  
	- White Box Testing 
		- The inner-workings of the program are **known** to the tester
		- Done by the <u>developer of the software</u>
		- <u>Knowledge</u> of the code and <u>implementation is required</u>
		- Inner or internal software testing
		
	- Grey Box Testing 
		- Grey Box is a Mix of Black Box and White Box Testing
		- (Pretty Self Explanatory)
		
	


## The <u>Deployment</u> and <u>Maintenance</u> Phase

This is where the product will be formally deployed by the developers for people to use, either as a whole or in stages.

In some cases, a select group of individuals will be allowed to trial the software before release. This is usually done to see if it is good enough to be used by the general public.

User Feedback or any problems surfaced will be solved and  maintained by the developer




And that completes all of the phases in a typical SDLC. This note is already getting pretty long, so I'll just split this into a 2-parter. The next file is going to cover the important SDLC Models that we have learnt. See you there!


---
Mikhail & Jabriel
